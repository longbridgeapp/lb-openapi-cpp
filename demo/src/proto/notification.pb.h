// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notification.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notification_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notification_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notification_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notification_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notification_2eproto;
namespace notification {
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Sub;
struct SubDefaultTypeInternal;
extern SubDefaultTypeInternal _Sub_default_instance_;
class SubResponse;
struct SubResponseDefaultTypeInternal;
extern SubResponseDefaultTypeInternal _SubResponse_default_instance_;
class SubResponse_Fail;
struct SubResponse_FailDefaultTypeInternal;
extern SubResponse_FailDefaultTypeInternal _SubResponse_Fail_default_instance_;
class Unsub;
struct UnsubDefaultTypeInternal;
extern UnsubDefaultTypeInternal _Unsub_default_instance_;
class UnsubResponse;
struct UnsubResponseDefaultTypeInternal;
extern UnsubResponseDefaultTypeInternal _UnsubResponse_default_instance_;
}  // namespace notification
PROTOBUF_NAMESPACE_OPEN
template<> ::notification::Notification* Arena::CreateMaybeMessage<::notification::Notification>(Arena*);
template<> ::notification::Sub* Arena::CreateMaybeMessage<::notification::Sub>(Arena*);
template<> ::notification::SubResponse* Arena::CreateMaybeMessage<::notification::SubResponse>(Arena*);
template<> ::notification::SubResponse_Fail* Arena::CreateMaybeMessage<::notification::SubResponse_Fail>(Arena*);
template<> ::notification::Unsub* Arena::CreateMaybeMessage<::notification::Unsub>(Arena*);
template<> ::notification::UnsubResponse* Arena::CreateMaybeMessage<::notification::UnsubResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace notification {

enum Command : int {
  UNKNOWN = 0,
  Subscribe = 16,
  UnSubscribe = 17,
  Notify = 18,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Command_IsValid(int value);
constexpr Command Command_MIN = UNKNOWN;
constexpr Command Command_MAX = Notify;
constexpr int Command_ARRAYSIZE = Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_descriptor();
template<typename T>
inline const std::string& Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_descriptor(), enum_t_value);
}
inline bool Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum DispatchType : int {
  DISPATCH_UNDEFINED = 0,
  DISPATCH_DIRECT = 1,
  DISPATCH_BROADCAST = 2,
  DispatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DispatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DispatchType_IsValid(int value);
constexpr DispatchType DispatchType_MIN = DISPATCH_UNDEFINED;
constexpr DispatchType DispatchType_MAX = DISPATCH_BROADCAST;
constexpr int DispatchType_ARRAYSIZE = DispatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DispatchType_descriptor();
template<typename T>
inline const std::string& DispatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DispatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DispatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DispatchType_descriptor(), enum_t_value);
}
inline bool DispatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DispatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DispatchType>(
    DispatchType_descriptor(), name, value);
}
enum ContentType : int {
  CONTENT_UNDEFINED = 0,
  CONTENT_JSON = 1,
  CONTENT_PROTO = 2,
  ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContentType_IsValid(int value);
constexpr ContentType ContentType_MIN = CONTENT_UNDEFINED;
constexpr ContentType ContentType_MAX = CONTENT_PROTO;
constexpr int ContentType_ARRAYSIZE = ContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentType_descriptor();
template<typename T>
inline const std::string& ContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentType_descriptor(), enum_t_value);
}
inline bool ContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentType>(
    ContentType_descriptor(), name, value);
}
// ===================================================================

class Sub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.Sub) */ {
 public:
  inline Sub() : Sub(nullptr) {}
  ~Sub() override;
  explicit constexpr Sub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sub(const Sub& from);
  Sub(Sub&& from) noexcept
    : Sub() {
    *this = ::std::move(from);
  }

  inline Sub& operator=(const Sub& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sub& operator=(Sub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sub& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sub* internal_default_instance() {
    return reinterpret_cast<const Sub*>(
               &_Sub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Sub& a, Sub& b) {
    a.Swap(&b);
  }
  inline void Swap(Sub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sub* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Sub& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.Sub";
  }
  protected:
  explicit Sub(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 1,
  };
  // repeated string topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // @@protoc_insertion_point(class_scope:notification.Sub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class SubResponse_Fail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.SubResponse.Fail) */ {
 public:
  inline SubResponse_Fail() : SubResponse_Fail(nullptr) {}
  ~SubResponse_Fail() override;
  explicit constexpr SubResponse_Fail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubResponse_Fail(const SubResponse_Fail& from);
  SubResponse_Fail(SubResponse_Fail&& from) noexcept
    : SubResponse_Fail() {
    *this = ::std::move(from);
  }

  inline SubResponse_Fail& operator=(const SubResponse_Fail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubResponse_Fail& operator=(SubResponse_Fail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubResponse_Fail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubResponse_Fail* internal_default_instance() {
    return reinterpret_cast<const SubResponse_Fail*>(
               &_SubResponse_Fail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubResponse_Fail& a, SubResponse_Fail& b) {
    a.Swap(&b);
  }
  inline void Swap(SubResponse_Fail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubResponse_Fail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubResponse_Fail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubResponse_Fail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubResponse_Fail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubResponse_Fail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubResponse_Fail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.SubResponse.Fail";
  }
  protected:
  explicit SubResponse_Fail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:notification.SubResponse.Fail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class SubResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.SubResponse) */ {
 public:
  inline SubResponse() : SubResponse(nullptr) {}
  ~SubResponse() override;
  explicit constexpr SubResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubResponse(const SubResponse& from);
  SubResponse(SubResponse&& from) noexcept
    : SubResponse() {
    *this = ::std::move(from);
  }

  inline SubResponse& operator=(const SubResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubResponse& operator=(SubResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubResponse* internal_default_instance() {
    return reinterpret_cast<const SubResponse*>(
               &_SubResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubResponse& a, SubResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.SubResponse";
  }
  protected:
  explicit SubResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubResponse_Fail Fail;

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailFieldNumber = 2,
    kCurrentFieldNumber = 3,
  };
  // repeated string success = 1;
  int success_size() const;
  private:
  int _internal_success_size() const;
  public:
  void clear_success();
  const std::string& success(int index) const;
  std::string* mutable_success(int index);
  void set_success(int index, const std::string& value);
  void set_success(int index, std::string&& value);
  void set_success(int index, const char* value);
  void set_success(int index, const char* value, size_t size);
  std::string* add_success();
  void add_success(const std::string& value);
  void add_success(std::string&& value);
  void add_success(const char* value);
  void add_success(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_success();
  private:
  const std::string& _internal_success(int index) const;
  std::string* _internal_add_success();
  public:

  // repeated .notification.SubResponse.Fail fail = 2;
  int fail_size() const;
  private:
  int _internal_fail_size() const;
  public:
  void clear_fail();
  ::notification::SubResponse_Fail* mutable_fail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notification::SubResponse_Fail >*
      mutable_fail();
  private:
  const ::notification::SubResponse_Fail& _internal_fail(int index) const;
  ::notification::SubResponse_Fail* _internal_add_fail();
  public:
  const ::notification::SubResponse_Fail& fail(int index) const;
  ::notification::SubResponse_Fail* add_fail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notification::SubResponse_Fail >&
      fail() const;

  // repeated string current = 3;
  int current_size() const;
  private:
  int _internal_current_size() const;
  public:
  void clear_current();
  const std::string& current(int index) const;
  std::string* mutable_current(int index);
  void set_current(int index, const std::string& value);
  void set_current(int index, std::string&& value);
  void set_current(int index, const char* value);
  void set_current(int index, const char* value, size_t size);
  std::string* add_current();
  void add_current(const std::string& value);
  void add_current(std::string&& value);
  void add_current(const char* value);
  void add_current(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current();
  private:
  const std::string& _internal_current(int index) const;
  std::string* _internal_add_current();
  public:

  // @@protoc_insertion_point(class_scope:notification.SubResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> success_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notification::SubResponse_Fail > fail_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class Unsub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.Unsub) */ {
 public:
  inline Unsub() : Unsub(nullptr) {}
  ~Unsub() override;
  explicit constexpr Unsub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unsub(const Unsub& from);
  Unsub(Unsub&& from) noexcept
    : Unsub() {
    *this = ::std::move(from);
  }

  inline Unsub& operator=(const Unsub& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsub& operator=(Unsub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsub& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unsub* internal_default_instance() {
    return reinterpret_cast<const Unsub*>(
               &_Unsub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Unsub& a, Unsub& b) {
    a.Swap(&b);
  }
  inline void Swap(Unsub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsub* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unsub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Unsub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unsub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Unsub& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.Unsub";
  }
  protected:
  explicit Unsub(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 1,
  };
  // repeated string topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // @@protoc_insertion_point(class_scope:notification.Unsub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class UnsubResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.UnsubResponse) */ {
 public:
  inline UnsubResponse() : UnsubResponse(nullptr) {}
  ~UnsubResponse() override;
  explicit constexpr UnsubResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubResponse(const UnsubResponse& from);
  UnsubResponse(UnsubResponse&& from) noexcept
    : UnsubResponse() {
    *this = ::std::move(from);
  }

  inline UnsubResponse& operator=(const UnsubResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubResponse& operator=(UnsubResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubResponse* internal_default_instance() {
    return reinterpret_cast<const UnsubResponse*>(
               &_UnsubResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UnsubResponse& a, UnsubResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsubResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.UnsubResponse";
  }
  protected:
  explicit UnsubResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 3,
  };
  // repeated string current = 3;
  int current_size() const;
  private:
  int _internal_current_size() const;
  public:
  void clear_current();
  const std::string& current(int index) const;
  std::string* mutable_current(int index);
  void set_current(int index, const std::string& value);
  void set_current(int index, std::string&& value);
  void set_current(int index, const char* value);
  void set_current(int index, const char* value, size_t size);
  std::string* add_current();
  void add_current(const std::string& value);
  void add_current(std::string&& value);
  void add_current(const char* value);
  void add_current(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current();
  private:
  const std::string& _internal_current(int index) const;
  std::string* _internal_add_current();
  public:

  // @@protoc_insertion_point(class_scope:notification.UnsubResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notification.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit constexpr Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Notification& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notification.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kDataFieldNumber = 4,
    kContentTypeFieldNumber = 2,
    kDispatchTypeFieldNumber = 3,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .notification.ContentType content_type = 2;
  void clear_content_type();
  ::notification::ContentType content_type() const;
  void set_content_type(::notification::ContentType value);
  private:
  ::notification::ContentType _internal_content_type() const;
  void _internal_set_content_type(::notification::ContentType value);
  public:

  // .notification.DispatchType dispatch_type = 3;
  void clear_dispatch_type();
  ::notification::DispatchType dispatch_type() const;
  void set_dispatch_type(::notification::DispatchType value);
  private:
  ::notification::DispatchType _internal_dispatch_type() const;
  void _internal_set_dispatch_type(::notification::DispatchType value);
  public:

  // @@protoc_insertion_point(class_scope:notification.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int content_type_;
  int dispatch_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Sub

// repeated string topics = 1;
inline int Sub::_internal_topics_size() const {
  return topics_.size();
}
inline int Sub::topics_size() const {
  return _internal_topics_size();
}
inline void Sub::clear_topics() {
  topics_.Clear();
}
inline std::string* Sub::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:notification.Sub.topics)
  return _s;
}
inline const std::string& Sub::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const std::string& Sub::topics(int index) const {
  // @@protoc_insertion_point(field_get:notification.Sub.topics)
  return _internal_topics(index);
}
inline std::string* Sub::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:notification.Sub.topics)
  return topics_.Mutable(index);
}
inline void Sub::set_topics(int index, const std::string& value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:notification.Sub.topics)
}
inline void Sub::set_topics(int index, std::string&& value) {
  topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:notification.Sub.topics)
}
inline void Sub::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:notification.Sub.topics)
}
inline void Sub::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:notification.Sub.topics)
}
inline std::string* Sub::_internal_add_topics() {
  return topics_.Add();
}
inline void Sub::add_topics(const std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:notification.Sub.topics)
}
inline void Sub::add_topics(std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:notification.Sub.topics)
}
inline void Sub::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:notification.Sub.topics)
}
inline void Sub::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:notification.Sub.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Sub::topics() const {
  // @@protoc_insertion_point(field_list:notification.Sub.topics)
  return topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Sub::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:notification.Sub.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// SubResponse_Fail

// string topic = 1;
inline void SubResponse_Fail::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& SubResponse_Fail::topic() const {
  // @@protoc_insertion_point(field_get:notification.SubResponse.Fail.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubResponse_Fail::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notification.SubResponse.Fail.topic)
}
inline std::string* SubResponse_Fail::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:notification.SubResponse.Fail.topic)
  return _s;
}
inline const std::string& SubResponse_Fail::_internal_topic() const {
  return topic_.Get();
}
inline void SubResponse_Fail::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubResponse_Fail::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubResponse_Fail::release_topic() {
  // @@protoc_insertion_point(field_release:notification.SubResponse.Fail.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubResponse_Fail::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notification.SubResponse.Fail.topic)
}

// string reason = 2;
inline void SubResponse_Fail::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& SubResponse_Fail::reason() const {
  // @@protoc_insertion_point(field_get:notification.SubResponse.Fail.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubResponse_Fail::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notification.SubResponse.Fail.reason)
}
inline std::string* SubResponse_Fail::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:notification.SubResponse.Fail.reason)
  return _s;
}
inline const std::string& SubResponse_Fail::_internal_reason() const {
  return reason_.Get();
}
inline void SubResponse_Fail::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubResponse_Fail::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubResponse_Fail::release_reason() {
  // @@protoc_insertion_point(field_release:notification.SubResponse.Fail.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubResponse_Fail::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notification.SubResponse.Fail.reason)
}

// -------------------------------------------------------------------

// SubResponse

// repeated string success = 1;
inline int SubResponse::_internal_success_size() const {
  return success_.size();
}
inline int SubResponse::success_size() const {
  return _internal_success_size();
}
inline void SubResponse::clear_success() {
  success_.Clear();
}
inline std::string* SubResponse::add_success() {
  std::string* _s = _internal_add_success();
  // @@protoc_insertion_point(field_add_mutable:notification.SubResponse.success)
  return _s;
}
inline const std::string& SubResponse::_internal_success(int index) const {
  return success_.Get(index);
}
inline const std::string& SubResponse::success(int index) const {
  // @@protoc_insertion_point(field_get:notification.SubResponse.success)
  return _internal_success(index);
}
inline std::string* SubResponse::mutable_success(int index) {
  // @@protoc_insertion_point(field_mutable:notification.SubResponse.success)
  return success_.Mutable(index);
}
inline void SubResponse::set_success(int index, const std::string& value) {
  success_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:notification.SubResponse.success)
}
inline void SubResponse::set_success(int index, std::string&& value) {
  success_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:notification.SubResponse.success)
}
inline void SubResponse::set_success(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  success_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:notification.SubResponse.success)
}
inline void SubResponse::set_success(int index, const char* value, size_t size) {
  success_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:notification.SubResponse.success)
}
inline std::string* SubResponse::_internal_add_success() {
  return success_.Add();
}
inline void SubResponse::add_success(const std::string& value) {
  success_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:notification.SubResponse.success)
}
inline void SubResponse::add_success(std::string&& value) {
  success_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:notification.SubResponse.success)
}
inline void SubResponse::add_success(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  success_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:notification.SubResponse.success)
}
inline void SubResponse::add_success(const char* value, size_t size) {
  success_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:notification.SubResponse.success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubResponse::success() const {
  // @@protoc_insertion_point(field_list:notification.SubResponse.success)
  return success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubResponse::mutable_success() {
  // @@protoc_insertion_point(field_mutable_list:notification.SubResponse.success)
  return &success_;
}

// repeated .notification.SubResponse.Fail fail = 2;
inline int SubResponse::_internal_fail_size() const {
  return fail_.size();
}
inline int SubResponse::fail_size() const {
  return _internal_fail_size();
}
inline void SubResponse::clear_fail() {
  fail_.Clear();
}
inline ::notification::SubResponse_Fail* SubResponse::mutable_fail(int index) {
  // @@protoc_insertion_point(field_mutable:notification.SubResponse.fail)
  return fail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notification::SubResponse_Fail >*
SubResponse::mutable_fail() {
  // @@protoc_insertion_point(field_mutable_list:notification.SubResponse.fail)
  return &fail_;
}
inline const ::notification::SubResponse_Fail& SubResponse::_internal_fail(int index) const {
  return fail_.Get(index);
}
inline const ::notification::SubResponse_Fail& SubResponse::fail(int index) const {
  // @@protoc_insertion_point(field_get:notification.SubResponse.fail)
  return _internal_fail(index);
}
inline ::notification::SubResponse_Fail* SubResponse::_internal_add_fail() {
  return fail_.Add();
}
inline ::notification::SubResponse_Fail* SubResponse::add_fail() {
  ::notification::SubResponse_Fail* _add = _internal_add_fail();
  // @@protoc_insertion_point(field_add:notification.SubResponse.fail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notification::SubResponse_Fail >&
SubResponse::fail() const {
  // @@protoc_insertion_point(field_list:notification.SubResponse.fail)
  return fail_;
}

// repeated string current = 3;
inline int SubResponse::_internal_current_size() const {
  return current_.size();
}
inline int SubResponse::current_size() const {
  return _internal_current_size();
}
inline void SubResponse::clear_current() {
  current_.Clear();
}
inline std::string* SubResponse::add_current() {
  std::string* _s = _internal_add_current();
  // @@protoc_insertion_point(field_add_mutable:notification.SubResponse.current)
  return _s;
}
inline const std::string& SubResponse::_internal_current(int index) const {
  return current_.Get(index);
}
inline const std::string& SubResponse::current(int index) const {
  // @@protoc_insertion_point(field_get:notification.SubResponse.current)
  return _internal_current(index);
}
inline std::string* SubResponse::mutable_current(int index) {
  // @@protoc_insertion_point(field_mutable:notification.SubResponse.current)
  return current_.Mutable(index);
}
inline void SubResponse::set_current(int index, const std::string& value) {
  current_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:notification.SubResponse.current)
}
inline void SubResponse::set_current(int index, std::string&& value) {
  current_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:notification.SubResponse.current)
}
inline void SubResponse::set_current(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:notification.SubResponse.current)
}
inline void SubResponse::set_current(int index, const char* value, size_t size) {
  current_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:notification.SubResponse.current)
}
inline std::string* SubResponse::_internal_add_current() {
  return current_.Add();
}
inline void SubResponse::add_current(const std::string& value) {
  current_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:notification.SubResponse.current)
}
inline void SubResponse::add_current(std::string&& value) {
  current_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:notification.SubResponse.current)
}
inline void SubResponse::add_current(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:notification.SubResponse.current)
}
inline void SubResponse::add_current(const char* value, size_t size) {
  current_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:notification.SubResponse.current)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubResponse::current() const {
  // @@protoc_insertion_point(field_list:notification.SubResponse.current)
  return current_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubResponse::mutable_current() {
  // @@protoc_insertion_point(field_mutable_list:notification.SubResponse.current)
  return &current_;
}

// -------------------------------------------------------------------

// Unsub

// repeated string topics = 1;
inline int Unsub::_internal_topics_size() const {
  return topics_.size();
}
inline int Unsub::topics_size() const {
  return _internal_topics_size();
}
inline void Unsub::clear_topics() {
  topics_.Clear();
}
inline std::string* Unsub::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:notification.Unsub.topics)
  return _s;
}
inline const std::string& Unsub::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const std::string& Unsub::topics(int index) const {
  // @@protoc_insertion_point(field_get:notification.Unsub.topics)
  return _internal_topics(index);
}
inline std::string* Unsub::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:notification.Unsub.topics)
  return topics_.Mutable(index);
}
inline void Unsub::set_topics(int index, const std::string& value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:notification.Unsub.topics)
}
inline void Unsub::set_topics(int index, std::string&& value) {
  topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:notification.Unsub.topics)
}
inline void Unsub::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:notification.Unsub.topics)
}
inline void Unsub::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:notification.Unsub.topics)
}
inline std::string* Unsub::_internal_add_topics() {
  return topics_.Add();
}
inline void Unsub::add_topics(const std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:notification.Unsub.topics)
}
inline void Unsub::add_topics(std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:notification.Unsub.topics)
}
inline void Unsub::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:notification.Unsub.topics)
}
inline void Unsub::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:notification.Unsub.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Unsub::topics() const {
  // @@protoc_insertion_point(field_list:notification.Unsub.topics)
  return topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Unsub::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:notification.Unsub.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// UnsubResponse

// repeated string current = 3;
inline int UnsubResponse::_internal_current_size() const {
  return current_.size();
}
inline int UnsubResponse::current_size() const {
  return _internal_current_size();
}
inline void UnsubResponse::clear_current() {
  current_.Clear();
}
inline std::string* UnsubResponse::add_current() {
  std::string* _s = _internal_add_current();
  // @@protoc_insertion_point(field_add_mutable:notification.UnsubResponse.current)
  return _s;
}
inline const std::string& UnsubResponse::_internal_current(int index) const {
  return current_.Get(index);
}
inline const std::string& UnsubResponse::current(int index) const {
  // @@protoc_insertion_point(field_get:notification.UnsubResponse.current)
  return _internal_current(index);
}
inline std::string* UnsubResponse::mutable_current(int index) {
  // @@protoc_insertion_point(field_mutable:notification.UnsubResponse.current)
  return current_.Mutable(index);
}
inline void UnsubResponse::set_current(int index, const std::string& value) {
  current_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:notification.UnsubResponse.current)
}
inline void UnsubResponse::set_current(int index, std::string&& value) {
  current_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:notification.UnsubResponse.current)
}
inline void UnsubResponse::set_current(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:notification.UnsubResponse.current)
}
inline void UnsubResponse::set_current(int index, const char* value, size_t size) {
  current_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:notification.UnsubResponse.current)
}
inline std::string* UnsubResponse::_internal_add_current() {
  return current_.Add();
}
inline void UnsubResponse::add_current(const std::string& value) {
  current_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:notification.UnsubResponse.current)
}
inline void UnsubResponse::add_current(std::string&& value) {
  current_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:notification.UnsubResponse.current)
}
inline void UnsubResponse::add_current(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:notification.UnsubResponse.current)
}
inline void UnsubResponse::add_current(const char* value, size_t size) {
  current_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:notification.UnsubResponse.current)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnsubResponse::current() const {
  // @@protoc_insertion_point(field_list:notification.UnsubResponse.current)
  return current_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnsubResponse::mutable_current() {
  // @@protoc_insertion_point(field_mutable_list:notification.UnsubResponse.current)
  return &current_;
}

// -------------------------------------------------------------------

// Notification

// string topic = 1;
inline void Notification::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& Notification::topic() const {
  // @@protoc_insertion_point(field_get:notification.Notification.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notification.Notification.topic)
}
inline std::string* Notification::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:notification.Notification.topic)
  return _s;
}
inline const std::string& Notification::_internal_topic() const {
  return topic_.Get();
}
inline void Notification::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Notification::release_topic() {
  // @@protoc_insertion_point(field_release:notification.Notification.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Notification::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notification.Notification.topic)
}

// .notification.ContentType content_type = 2;
inline void Notification::clear_content_type() {
  content_type_ = 0;
}
inline ::notification::ContentType Notification::_internal_content_type() const {
  return static_cast< ::notification::ContentType >(content_type_);
}
inline ::notification::ContentType Notification::content_type() const {
  // @@protoc_insertion_point(field_get:notification.Notification.content_type)
  return _internal_content_type();
}
inline void Notification::_internal_set_content_type(::notification::ContentType value) {
  
  content_type_ = value;
}
inline void Notification::set_content_type(::notification::ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:notification.Notification.content_type)
}

// .notification.DispatchType dispatch_type = 3;
inline void Notification::clear_dispatch_type() {
  dispatch_type_ = 0;
}
inline ::notification::DispatchType Notification::_internal_dispatch_type() const {
  return static_cast< ::notification::DispatchType >(dispatch_type_);
}
inline ::notification::DispatchType Notification::dispatch_type() const {
  // @@protoc_insertion_point(field_get:notification.Notification.dispatch_type)
  return _internal_dispatch_type();
}
inline void Notification::_internal_set_dispatch_type(::notification::DispatchType value) {
  
  dispatch_type_ = value;
}
inline void Notification::set_dispatch_type(::notification::DispatchType value) {
  _internal_set_dispatch_type(value);
  // @@protoc_insertion_point(field_set:notification.Notification.dispatch_type)
}

// bytes data = 4;
inline void Notification::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Notification::data() const {
  // @@protoc_insertion_point(field_get:notification.Notification.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notification.Notification.data)
}
inline std::string* Notification::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:notification.Notification.data)
  return _s;
}
inline const std::string& Notification::_internal_data() const {
  return data_.Get();
}
inline void Notification::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Notification::release_data() {
  // @@protoc_insertion_point(field_release:notification.Notification.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Notification::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notification.Notification.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace notification

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::notification::Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::notification::Command>() {
  return ::notification::Command_descriptor();
}
template <> struct is_proto_enum< ::notification::DispatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::notification::DispatchType>() {
  return ::notification::DispatchType_descriptor();
}
template <> struct is_proto_enum< ::notification::ContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::notification::ContentType>() {
  return ::notification::ContentType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notification_2eproto
